function Q = PLC_wrapper(X, F, params)
% =========================================================================
% PLC_wrapper: 调用多视图 PLC 核心函数并提供安全回退机制
%
% 描述 (重构版):
%   本函数是 B 路（Path B）的执行器。它将多视图处理的复杂逻辑
%   委托给专门的 PLC_mv.m 函数，自身只负责调用和错误处理。
%
%   1. 调用 PLC_mv.m 来执行“逐视图聚类->对齐->投票”的完整流程。
%   2. 如果 PLC_mv.m 成功，则返回其结果。
%   3. 如果 PLC_mv.m 在任何环节失败，则捕获错误，并安全回退到使用
%      A 路自身的结果 F 作为参考。
%
% 输入:
%   X       - 全量数据的特征 (cell array, V个视图)
%   F       - A 路当前迭代的内生伪标签 (n x c)
%   params  - 包含所有超参数的结构体 (其中 params.plc 会被传入 PLC_mv)
%
% 输出:
%   Q       - B 路生成的多视图共识伪标签 (n x c, one-hot)
% =========================================================================
    try
        % -----------------------------------------------------------------
        % 步骤 1: 调用专门的多视图 PLC 函数
        % -----------------------------------------------------------------
        fprintf('    正在调用 PLC_mv (多视图处理模块)...\n');
        Q = PLC_mv(X, F, params.plc);
        fprintf('    PLC 多视图共识成功.\n');

    catch ME % ME 是 MATLAB 的错误信息结构体
        % -----------------------------------------------------------------
        % 步骤 2: PLC 失败后的安全回退 (Safe Fallback)
        % -----------------------------------------------------------------
        fprintf(2, '    PLC 流程失败: %s\n', ME.message);
        fprintf(2, '    警告: B路刷新失败! 正在回退到使用A路自身的结果 F (硬化标签)。\n');
        
        [~, F_hard_labels] = max(F, [], 2);
        Q = full(sparse(1:size(F, 1), F_hard_labels, 1, size(F, 1), size(F, 2)));
    end
end

